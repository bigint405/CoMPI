// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.30.1
// source: rpc_service.proto

package rpc_server

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	GetTargetDeviceService_GetTarget_FullMethodName = "/GetTargetDeviceService/GetTarget"
)

// GetTargetDeviceServiceClient is the client API for GetTargetDeviceService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GetTargetDeviceServiceClient interface {
	GetTarget(ctx context.Context, in *GetTargetRequest, opts ...grpc.CallOption) (*GetTargetResponse, error)
}

type getTargetDeviceServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewGetTargetDeviceServiceClient(cc grpc.ClientConnInterface) GetTargetDeviceServiceClient {
	return &getTargetDeviceServiceClient{cc}
}

func (c *getTargetDeviceServiceClient) GetTarget(ctx context.Context, in *GetTargetRequest, opts ...grpc.CallOption) (*GetTargetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTargetResponse)
	err := c.cc.Invoke(ctx, GetTargetDeviceService_GetTarget_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GetTargetDeviceServiceServer is the server API for GetTargetDeviceService service.
// All implementations must embed UnimplementedGetTargetDeviceServiceServer
// for forward compatibility.
type GetTargetDeviceServiceServer interface {
	GetTarget(context.Context, *GetTargetRequest) (*GetTargetResponse, error)
	mustEmbedUnimplementedGetTargetDeviceServiceServer()
}

// UnimplementedGetTargetDeviceServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedGetTargetDeviceServiceServer struct{}

func (UnimplementedGetTargetDeviceServiceServer) GetTarget(context.Context, *GetTargetRequest) (*GetTargetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTarget not implemented")
}
func (UnimplementedGetTargetDeviceServiceServer) mustEmbedUnimplementedGetTargetDeviceServiceServer() {
}
func (UnimplementedGetTargetDeviceServiceServer) testEmbeddedByValue() {}

// UnsafeGetTargetDeviceServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GetTargetDeviceServiceServer will
// result in compilation errors.
type UnsafeGetTargetDeviceServiceServer interface {
	mustEmbedUnimplementedGetTargetDeviceServiceServer()
}

func RegisterGetTargetDeviceServiceServer(s grpc.ServiceRegistrar, srv GetTargetDeviceServiceServer) {
	// If the following call pancis, it indicates UnimplementedGetTargetDeviceServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&GetTargetDeviceService_ServiceDesc, srv)
}

func _GetTargetDeviceService_GetTarget_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTargetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GetTargetDeviceServiceServer).GetTarget(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GetTargetDeviceService_GetTarget_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GetTargetDeviceServiceServer).GetTarget(ctx, req.(*GetTargetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// GetTargetDeviceService_ServiceDesc is the grpc.ServiceDesc for GetTargetDeviceService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GetTargetDeviceService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "GetTargetDeviceService",
	HandlerType: (*GetTargetDeviceServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetTarget",
			Handler:    _GetTargetDeviceService_GetTarget_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc_service.proto",
}

const (
	FinishBatchService_FinishBatch_FullMethodName = "/FinishBatchService/FinishBatch"
)

// FinishBatchServiceClient is the client API for FinishBatchService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FinishBatchServiceClient interface {
	FinishBatch(ctx context.Context, in *FinishBatchRequest, opts ...grpc.CallOption) (*FinishBatchResponse, error)
}

type finishBatchServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFinishBatchServiceClient(cc grpc.ClientConnInterface) FinishBatchServiceClient {
	return &finishBatchServiceClient{cc}
}

func (c *finishBatchServiceClient) FinishBatch(ctx context.Context, in *FinishBatchRequest, opts ...grpc.CallOption) (*FinishBatchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FinishBatchResponse)
	err := c.cc.Invoke(ctx, FinishBatchService_FinishBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FinishBatchServiceServer is the server API for FinishBatchService service.
// All implementations must embed UnimplementedFinishBatchServiceServer
// for forward compatibility.
type FinishBatchServiceServer interface {
	FinishBatch(context.Context, *FinishBatchRequest) (*FinishBatchResponse, error)
	mustEmbedUnimplementedFinishBatchServiceServer()
}

// UnimplementedFinishBatchServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFinishBatchServiceServer struct{}

func (UnimplementedFinishBatchServiceServer) FinishBatch(context.Context, *FinishBatchRequest) (*FinishBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FinishBatch not implemented")
}
func (UnimplementedFinishBatchServiceServer) mustEmbedUnimplementedFinishBatchServiceServer() {}
func (UnimplementedFinishBatchServiceServer) testEmbeddedByValue()                            {}

// UnsafeFinishBatchServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FinishBatchServiceServer will
// result in compilation errors.
type UnsafeFinishBatchServiceServer interface {
	mustEmbedUnimplementedFinishBatchServiceServer()
}

func RegisterFinishBatchServiceServer(s grpc.ServiceRegistrar, srv FinishBatchServiceServer) {
	// If the following call pancis, it indicates UnimplementedFinishBatchServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FinishBatchService_ServiceDesc, srv)
}

func _FinishBatchService_FinishBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FinishBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FinishBatchServiceServer).FinishBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FinishBatchService_FinishBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FinishBatchServiceServer).FinishBatch(ctx, req.(*FinishBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FinishBatchService_ServiceDesc is the grpc.ServiceDesc for FinishBatchService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FinishBatchService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "FinishBatchService",
	HandlerType: (*FinishBatchServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "FinishBatch",
			Handler:    _FinishBatchService_FinishBatch_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc_service.proto",
}

const (
	FinishInferService_FinishInfer_FullMethodName = "/FinishInferService/FinishInfer"
)

// FinishInferServiceClient is the client API for FinishInferService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FinishInferServiceClient interface {
	FinishInfer(ctx context.Context, in *FinishInferRequest, opts ...grpc.CallOption) (*FinishInferResponse, error)
}

type finishInferServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFinishInferServiceClient(cc grpc.ClientConnInterface) FinishInferServiceClient {
	return &finishInferServiceClient{cc}
}

func (c *finishInferServiceClient) FinishInfer(ctx context.Context, in *FinishInferRequest, opts ...grpc.CallOption) (*FinishInferResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FinishInferResponse)
	err := c.cc.Invoke(ctx, FinishInferService_FinishInfer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FinishInferServiceServer is the server API for FinishInferService service.
// All implementations must embed UnimplementedFinishInferServiceServer
// for forward compatibility.
type FinishInferServiceServer interface {
	FinishInfer(context.Context, *FinishInferRequest) (*FinishInferResponse, error)
	mustEmbedUnimplementedFinishInferServiceServer()
}

// UnimplementedFinishInferServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFinishInferServiceServer struct{}

func (UnimplementedFinishInferServiceServer) FinishInfer(context.Context, *FinishInferRequest) (*FinishInferResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FinishInfer not implemented")
}
func (UnimplementedFinishInferServiceServer) mustEmbedUnimplementedFinishInferServiceServer() {}
func (UnimplementedFinishInferServiceServer) testEmbeddedByValue()                            {}

// UnsafeFinishInferServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FinishInferServiceServer will
// result in compilation errors.
type UnsafeFinishInferServiceServer interface {
	mustEmbedUnimplementedFinishInferServiceServer()
}

func RegisterFinishInferServiceServer(s grpc.ServiceRegistrar, srv FinishInferServiceServer) {
	// If the following call pancis, it indicates UnimplementedFinishInferServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FinishInferService_ServiceDesc, srv)
}

func _FinishInferService_FinishInfer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FinishInferRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FinishInferServiceServer).FinishInfer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FinishInferService_FinishInfer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FinishInferServiceServer).FinishInfer(ctx, req.(*FinishInferRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FinishInferService_ServiceDesc is the grpc.ServiceDesc for FinishInferService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FinishInferService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "FinishInferService",
	HandlerType: (*FinishInferServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "FinishInfer",
			Handler:    _FinishInferService_FinishInfer_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc_service.proto",
}

const (
	SetTargetDeviceService_SetTarget_FullMethodName = "/SetTargetDeviceService/SetTarget"
)

// SetTargetDeviceServiceClient is the client API for SetTargetDeviceService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SetTargetDeviceServiceClient interface {
	SetTarget(ctx context.Context, in *SetTargetRequest, opts ...grpc.CallOption) (*SetTargetResponse, error)
}

type setTargetDeviceServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSetTargetDeviceServiceClient(cc grpc.ClientConnInterface) SetTargetDeviceServiceClient {
	return &setTargetDeviceServiceClient{cc}
}

func (c *setTargetDeviceServiceClient) SetTarget(ctx context.Context, in *SetTargetRequest, opts ...grpc.CallOption) (*SetTargetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetTargetResponse)
	err := c.cc.Invoke(ctx, SetTargetDeviceService_SetTarget_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SetTargetDeviceServiceServer is the server API for SetTargetDeviceService service.
// All implementations must embed UnimplementedSetTargetDeviceServiceServer
// for forward compatibility.
type SetTargetDeviceServiceServer interface {
	SetTarget(context.Context, *SetTargetRequest) (*SetTargetResponse, error)
	mustEmbedUnimplementedSetTargetDeviceServiceServer()
}

// UnimplementedSetTargetDeviceServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSetTargetDeviceServiceServer struct{}

func (UnimplementedSetTargetDeviceServiceServer) SetTarget(context.Context, *SetTargetRequest) (*SetTargetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetTarget not implemented")
}
func (UnimplementedSetTargetDeviceServiceServer) mustEmbedUnimplementedSetTargetDeviceServiceServer() {
}
func (UnimplementedSetTargetDeviceServiceServer) testEmbeddedByValue() {}

// UnsafeSetTargetDeviceServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SetTargetDeviceServiceServer will
// result in compilation errors.
type UnsafeSetTargetDeviceServiceServer interface {
	mustEmbedUnimplementedSetTargetDeviceServiceServer()
}

func RegisterSetTargetDeviceServiceServer(s grpc.ServiceRegistrar, srv SetTargetDeviceServiceServer) {
	// If the following call pancis, it indicates UnimplementedSetTargetDeviceServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SetTargetDeviceService_ServiceDesc, srv)
}

func _SetTargetDeviceService_SetTarget_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetTargetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SetTargetDeviceServiceServer).SetTarget(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SetTargetDeviceService_SetTarget_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SetTargetDeviceServiceServer).SetTarget(ctx, req.(*SetTargetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SetTargetDeviceService_ServiceDesc is the grpc.ServiceDesc for SetTargetDeviceService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SetTargetDeviceService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "SetTargetDeviceService",
	HandlerType: (*SetTargetDeviceServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetTarget",
			Handler:    _SetTargetDeviceService_SetTarget_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc_service.proto",
}

const (
	StartInferService_StartInfer_FullMethodName = "/StartInferService/StartInfer"
)

// StartInferServiceClient is the client API for StartInferService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type StartInferServiceClient interface {
	StartInfer(ctx context.Context, in *StartInferRequest, opts ...grpc.CallOption) (*StartInferResponse, error)
}

type startInferServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewStartInferServiceClient(cc grpc.ClientConnInterface) StartInferServiceClient {
	return &startInferServiceClient{cc}
}

func (c *startInferServiceClient) StartInfer(ctx context.Context, in *StartInferRequest, opts ...grpc.CallOption) (*StartInferResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StartInferResponse)
	err := c.cc.Invoke(ctx, StartInferService_StartInfer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StartInferServiceServer is the server API for StartInferService service.
// All implementations must embed UnimplementedStartInferServiceServer
// for forward compatibility.
type StartInferServiceServer interface {
	StartInfer(context.Context, *StartInferRequest) (*StartInferResponse, error)
	mustEmbedUnimplementedStartInferServiceServer()
}

// UnimplementedStartInferServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedStartInferServiceServer struct{}

func (UnimplementedStartInferServiceServer) StartInfer(context.Context, *StartInferRequest) (*StartInferResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartInfer not implemented")
}
func (UnimplementedStartInferServiceServer) mustEmbedUnimplementedStartInferServiceServer() {}
func (UnimplementedStartInferServiceServer) testEmbeddedByValue()                           {}

// UnsafeStartInferServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StartInferServiceServer will
// result in compilation errors.
type UnsafeStartInferServiceServer interface {
	mustEmbedUnimplementedStartInferServiceServer()
}

func RegisterStartInferServiceServer(s grpc.ServiceRegistrar, srv StartInferServiceServer) {
	// If the following call pancis, it indicates UnimplementedStartInferServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&StartInferService_ServiceDesc, srv)
}

func _StartInferService_StartInfer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartInferRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StartInferServiceServer).StartInfer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StartInferService_StartInfer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StartInferServiceServer).StartInfer(ctx, req.(*StartInferRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// StartInferService_ServiceDesc is the grpc.ServiceDesc for StartInferService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var StartInferService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "StartInferService",
	HandlerType: (*StartInferServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StartInfer",
			Handler:    _StartInferService_StartInfer_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc_service.proto",
}

const (
	RegisterDeviceService_RegisterDevice_FullMethodName = "/RegisterDeviceService/RegisterDevice"
)

// RegisterDeviceServiceClient is the client API for RegisterDeviceService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RegisterDeviceServiceClient interface {
	RegisterDevice(ctx context.Context, in *RegisterDeviceRequest, opts ...grpc.CallOption) (*RegisterDeviceResponse, error)
}

type registerDeviceServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewRegisterDeviceServiceClient(cc grpc.ClientConnInterface) RegisterDeviceServiceClient {
	return &registerDeviceServiceClient{cc}
}

func (c *registerDeviceServiceClient) RegisterDevice(ctx context.Context, in *RegisterDeviceRequest, opts ...grpc.CallOption) (*RegisterDeviceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterDeviceResponse)
	err := c.cc.Invoke(ctx, RegisterDeviceService_RegisterDevice_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RegisterDeviceServiceServer is the server API for RegisterDeviceService service.
// All implementations must embed UnimplementedRegisterDeviceServiceServer
// for forward compatibility.
type RegisterDeviceServiceServer interface {
	RegisterDevice(context.Context, *RegisterDeviceRequest) (*RegisterDeviceResponse, error)
	mustEmbedUnimplementedRegisterDeviceServiceServer()
}

// UnimplementedRegisterDeviceServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRegisterDeviceServiceServer struct{}

func (UnimplementedRegisterDeviceServiceServer) RegisterDevice(context.Context, *RegisterDeviceRequest) (*RegisterDeviceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterDevice not implemented")
}
func (UnimplementedRegisterDeviceServiceServer) mustEmbedUnimplementedRegisterDeviceServiceServer() {}
func (UnimplementedRegisterDeviceServiceServer) testEmbeddedByValue()                               {}

// UnsafeRegisterDeviceServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RegisterDeviceServiceServer will
// result in compilation errors.
type UnsafeRegisterDeviceServiceServer interface {
	mustEmbedUnimplementedRegisterDeviceServiceServer()
}

func RegisterRegisterDeviceServiceServer(s grpc.ServiceRegistrar, srv RegisterDeviceServiceServer) {
	// If the following call pancis, it indicates UnimplementedRegisterDeviceServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&RegisterDeviceService_ServiceDesc, srv)
}

func _RegisterDeviceService_RegisterDevice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterDeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegisterDeviceServiceServer).RegisterDevice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegisterDeviceService_RegisterDevice_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegisterDeviceServiceServer).RegisterDevice(ctx, req.(*RegisterDeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RegisterDeviceService_ServiceDesc is the grpc.ServiceDesc for RegisterDeviceService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RegisterDeviceService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "RegisterDeviceService",
	HandlerType: (*RegisterDeviceServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterDevice",
			Handler:    _RegisterDeviceService_RegisterDevice_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc_service.proto",
}
